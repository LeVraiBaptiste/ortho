import type { Vowel, VowelTarget, FormantData } from './types'

const VOWEL_TARGETS: readonly VowelTarget[] = [
  { vowel: 'a', f1: 750, f2: 1450, f3: 2600 },
  { vowel: 'e', f1: 400, f2: 2050, f3: 2650 },
  { vowel: 'ɛ', f1: 600, f2: 1750, f3: 2600 },
  { vowel: 'i', f1: 250, f2: 2250, f3: 3000 },
  { vowel: 'o', f1: 350, f2: 750, f3: 2550 },
  { vowel: 'u', f1: 300, f2: 750, f3: 2300 },
  { vowel: 'y', f1: 250, f2: 1750, f3: 2150 },
] as const

// Expected low-frequency energy ratio for each vowel (back vowels have higher ratio)
const VOWEL_SPECTRAL_BALANCE: Record<string, number> = {
  'a': 0.55,  // mid — energy in both bands
  'e': 0.25,  // front — energy above 1500
  'ɛ': 0.35,  // front-mid
  'i': 0.15,  // front — energy concentrated above 1500
  'o': 0.75,  // back — energy concentrated below 1500
  'u': 0.80,  // back — energy concentrated below 1500
  'y': 0.20,  // front — similar to /i/ but with lip rounding
}

// Minimum RMS energy to consider the signal voiced
const ENERGY_THRESHOLD = 0.01

// Minimum magnitude for a spectral peak to be considered valid
const PEAK_MAGNITUDE_THRESHOLD = 0.001

// LPC analysis order (number of poles)
const LPC_ORDER = 12

// Convert Hz to Bark scale for perceptually uniform distance
export const hzToBark = (hz: number): number =>
  13 * Math.atan(0.00076 * hz) + 3.5 * Math.atan((hz / 7500) ** 2)

// --- Helper functions ---

export const applyHammingWindow = (buffer: Float32Array): Float32Array => {
  const n = buffer.length
  const windowed = new Float32Array(n)
  for (let i = 0; i < n; i++) {
    const w = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (n - 1))
    windowed[i] = buffer[i] * w
  }
  return windowed
}

// Pre-emphasis filter to boost high frequencies (compensates natural spectral rolloff)
export const applyPreEmphasis = (buffer: Float32Array, coeff: number = 0.97): Float32Array => {
  const result = new Float32Array(buffer.length)
  result[0] = buffer[0]
  for (let i = 1; i < buffer.length; i++) {
    result[i] = buffer[i] - coeff * buffer[i - 1]
  }
  return result
}

// Radix-2 Cooley-Tukey FFT (in-place, iterative)
// Returns magnitude spectrum (first N/2 + 1 bins)
export const computeFFTMagnitude = (buffer: Float32Array): Float32Array => {
  const n = nextPowerOfTwo(buffer.length)

  // Zero-pad if needed and create real/imag arrays
  const real = new Float32Array(n)
  const imag = new Float32Array(n)
  real.set(buffer.subarray(0, Math.min(buffer.length, n)))

  // Bit-reversal permutation
  bitReversalPermute(real, imag, n)

  // Cooley-Tukey butterfly stages
  for (let size = 2; size <= n; size *= 2) {
    const halfSize = size / 2
    const angleStep = (-2 * Math.PI) / size

    for (let i = 0; i < n; i += size) {
      for (let j = 0; j < halfSize; j++) {
        const angle = angleStep * j
        const twiddleReal = Math.cos(angle)
        const twiddleImag = Math.sin(angle)

        const evenIdx = i + j
        const oddIdx = i + j + halfSize

        const tReal = twiddleReal * real[oddIdx] - twiddleImag * imag[oddIdx]
        const tImag = twiddleReal * imag[oddIdx] + twiddleImag * real[oddIdx]

        real[oddIdx] = real[evenIdx] - tReal
        imag[oddIdx] = imag[evenIdx] - tImag
        real[evenIdx] = real[evenIdx] + tReal
        imag[evenIdx] = imag[evenIdx] + tImag
      }
    }
  }

  // Compute magnitude for the first half of the spectrum
  const numBins = n / 2 + 1
  const magnitudes = new Float32Array(numBins)
  for (let i = 0; i < numBins; i++) {
    magnitudes[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i])
  }
  return magnitudes
}

// Find the frequency of the highest magnitude peak in a given Hz range
export const findPeakInRange = (
  magnitudes: Float32Array,
  sampleRate: number,
  minHz: number,
  maxHz: number,
): number => {
  const n = (magnitudes.length - 1) * 2 // original FFT size
  const binToHz = sampleRate / n

  const minBin = Math.max(1, Math.ceil(minHz / binToHz))
  const maxBin = Math.min(magnitudes.length - 1, Math.floor(maxHz / binToHz))

  let peakBin = minBin
  let peakMag = magnitudes[minBin]

  for (let i = minBin + 1; i <= maxBin; i++) {
    if (magnitudes[i] > peakMag) {
      peakMag = magnitudes[i]
      peakBin = i
    }
  }

  // Parabolic interpolation around the peak for sub-bin accuracy
  if (peakBin > minBin && peakBin < maxBin) {
    const alpha = magnitudes[peakBin - 1]
    const beta = magnitudes[peakBin]
    const gamma = magnitudes[peakBin + 1]
    const denom = alpha - 2 * beta + gamma
    if (denom !== 0) {
      const correction = 0.5 * (alpha - gamma) / denom
      return (peakBin + correction) * binToHz
    }
  }

  return peakBin * binToHz
}

export const classifyVowel = (f1: number, f2: number, f3: number): Vowel => {
  const b1 = hzToBark(f1)
  const b2 = hzToBark(f2)
  const b3 = hzToBark(f3)

  let bestVowel: Vowel = VOWEL_TARGETS[0].vowel
  let bestDist = Infinity

  for (const target of VOWEL_TARGETS) {
    const d1 = b1 - hzToBark(target.f1)
    const d2 = b2 - hzToBark(target.f2)
    const d3 = b3 - hzToBark(target.f3)
    const dist = d1 * d1 + d2 * d2 + 0.8 * d3 * d3
    if (dist < bestDist) {
      bestDist = dist
      bestVowel = target.vowel
    }
  }

  return bestVowel
}

// --- LPC analysis ---

// Downsample with proper anti-aliasing: Hamming-windowed sinc low-pass FIR filter + decimation
const decimateSignal = (buffer: Float32Array, factor: number): Float32Array => {
  if (factor <= 1) return buffer

  // Design low-pass FIR filter: Hamming-windowed sinc
  const cutoff = 0.8 / factor  // normalized cutoff (fraction of original Nyquist)
  const numTaps = 4 * factor + 1
  const halfTaps = Math.floor(numTaps / 2)
  const kernel = new Float32Array(numTaps)

  let sum = 0
  for (let i = 0; i < numTaps; i++) {
    const n = i - halfTaps
    // Sinc function
    const sinc = n === 0 ? 2 * Math.PI * cutoff : Math.sin(2 * Math.PI * cutoff * n) / n
    // Hamming window
    const window = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (numTaps - 1))
    kernel[i] = sinc * window
    sum += kernel[i]
  }
  // Normalize
  for (let i = 0; i < numTaps; i++) kernel[i] /= sum

  // Apply filter then decimate
  const outLen = Math.floor(buffer.length / factor)
  const result = new Float32Array(outLen)
  for (let i = 0; i < outLen; i++) {
    const center = i * factor
    let val = 0
    for (let j = 0; j < numTaps; j++) {
      const idx = center + j - halfTaps
      if (idx >= 0 && idx < buffer.length) {
        val += buffer[idx] * kernel[j]
      }
    }
    result[i] = val
  }
  return result
}

// Autocorrelation R[0..order]
const computeAutocorrelation = (signal: Float32Array, order: number): Float32Array => {
  const n = signal.length
  const R = new Float32Array(order + 1)
  for (let k = 0; k <= order; k++) {
    let sum = 0
    for (let i = 0; i < n - k; i++) {
      sum += signal[i] * signal[i + k]
    }
    R[k] = sum
  }
  return R
}

// Levinson-Durbin recursion: autocorrelation -> LPC coefficients + gain
const levinsonDurbin = (R: Float32Array, order: number): { coeffs: Float32Array; gain: number } => {
  if (R[0] === 0) {
    return { coeffs: new Float32Array(order), gain: 1 }
  }

  const a = new Float32Array(order)
  let E = R[0]

  for (let i = 0; i < order; i++) {
    // Compute reflection coefficient
    let lambda = R[i + 1]
    for (let j = 0; j < i; j++) {
      lambda -= a[j] * R[i - j]
    }
    const ki = lambda / E

    // Update coefficients using a temporary copy
    const prev = new Float32Array(i)
    for (let j = 0; j < i; j++) {
      prev[j] = a[j]
    }

    a[i] = ki
    for (let j = 0; j < i; j++) {
      a[j] = prev[j] - ki * prev[i - 1 - j]
    }

    E *= (1 - ki * ki)
    if (E <= 0) {
      E = 1e-10
    }
  }

  return { coeffs: a, gain: Math.sqrt(E) }
}

// Burg's method: compute LPC coefficients directly from data
// More robust than autocorrelation method for short frames
const burgMethod = (signal: Float32Array, order: number): { coeffs: Float32Array; gain: number } => {
  const n = signal.length
  if (n === 0) return { coeffs: new Float32Array(order), gain: 1 }

  // Initialize forward and backward prediction errors
  let ef = new Float32Array(n)
  let eb = new Float32Array(n)
  for (let i = 0; i < n; i++) {
    ef[i] = signal[i]
    eb[i] = signal[i]
  }

  const a = new Float32Array(order)
  let E = 0
  for (let i = 0; i < n; i++) E += signal[i] * signal[i]
  E /= n

  for (let k = 0; k < order; k++) {
    // Compute reflection coefficient
    let num = 0
    let den = 0
    for (let i = k + 1; i < n; i++) {
      num += ef[i] * eb[i - 1]
      den += ef[i] * ef[i] + eb[i - 1] * eb[i - 1]
    }

    const rc = den > 0 ? -2.0 * num / den : 0

    // Update LPC coefficients
    const prev = new Float32Array(k)
    for (let j = 0; j < k; j++) prev[j] = a[j]
    a[k] = rc
    for (let j = 0; j < k; j++) {
      a[j] = prev[j] + rc * prev[k - 1 - j]
    }

    // Update prediction error power
    E *= (1 - rc * rc)
    if (E <= 0) E = 1e-10

    // Update forward and backward errors
    const newEf = new Float32Array(n)
    const newEb = new Float32Array(n)
    for (let i = k + 1; i < n; i++) {
      newEf[i] = ef[i] + rc * eb[i - 1]
      newEb[i] = eb[i - 1] + rc * ef[i]
    }
    ef = newEf
    eb = newEb
  }

  return { coeffs: a, gain: Math.sqrt(E * n) }
}

// Evaluate LPC spectral envelope |H(f)| = gain / |A(e^{jω})| at each FFT bin frequency
const evaluateLpcEnvelope = (
  coeffs: Float32Array,
  gain: number,
  numBins: number,
  decimatedSampleRate: number,
  originalSampleRate: number,
  originalFftSize: number,
): Float32Array => {
  const envelope = new Float32Array(numBins)
  const nyquist = decimatedSampleRate / 2
  const order = coeffs.length

  for (let i = 0; i < numBins; i++) {
    const freq = i * originalSampleRate / originalFftSize

    if (freq > nyquist) {
      envelope[i] = 0
      continue
    }

    const omega = (2 * Math.PI * freq) / decimatedSampleRate
    let aReal = 1
    let aImag = 0
    for (let k = 0; k < order; k++) {
      const angle = (k + 1) * omega
      aReal -= coeffs[k] * Math.cos(angle)
      aImag += coeffs[k] * Math.sin(angle)
    }

    const magSq = aReal * aReal + aImag * aImag
    envelope[i] = gain / Math.sqrt(magSq)
  }

  return envelope
}

// --- Local peak finding for formant extraction ---

type SpectralPeak = { readonly freq: number; readonly mag: number }

const findLocalPeaks = (
  envelope: Float32Array,
  sampleRate: number,
  minHz: number,
  maxHz: number,
): SpectralPeak[] => {
  const n = (envelope.length - 1) * 2
  const binToHz = sampleRate / n
  const minBin = Math.max(1, Math.ceil(minHz / binToHz))
  const maxBin = Math.min(envelope.length - 2, Math.floor(maxHz / binToHz))
  const peaks: SpectralPeak[] = []

  for (let i = minBin; i <= maxBin; i++) {
    if (envelope[i] > envelope[i - 1] && envelope[i] > envelope[i + 1]) {
      const alpha = envelope[i - 1]
      const beta = envelope[i]
      const gamma = envelope[i + 1]
      const denom = alpha - 2 * beta + gamma
      let freq = i * binToHz
      if (denom !== 0) {
        const correction = 0.5 * (alpha - gamma) / denom
        freq = (i + correction) * binToHz
      }
      peaks.push({ freq, mag: beta })
    }
  }

  return peaks
}

const findBestLocalPeakInRange = (
  envelope: Float32Array,
  sampleRate: number,
  minHz: number,
  maxHz: number,
): number => {
  // Find all local peaks in the full spectrum
  const peaks = findLocalPeaks(envelope, sampleRate, minHz, maxHz)
  if (peaks.length === 0) {
    return findPeakInRange(envelope, sampleRate, minHz, maxHz)
  }
  // Return frequency of strongest peak in range
  let best = peaks[0]
  for (const p of peaks) {
    if (p.mag > best.mag) best = p
  }
  return best.freq
}

const strongestPeakInRange = (
  peaks: readonly SpectralPeak[],
  minHz: number,
  maxHz: number,
): SpectralPeak | null => {
  let best: SpectralPeak | null = null
  for (const p of peaks) {
    if (p.freq >= minHz && p.freq <= maxHz && (best === null || p.mag > best.mag)) {
      best = p
    }
  }
  return best
}

const extractFormants = (
  envelope: Float32Array,
  sampleRate: number,
): { f1: number; f2: number; f3: number } => {
  const peaks = findLocalPeaks(envelope, sampleRate, 100, 4000)

  // Sort peaks by frequency so we assign formants in order
  const sorted = [...peaks].sort((a, b) => a.freq - b.freq)

  // F1: strongest peak in 200-1200 Hz (main vocal tract resonance)
  const f1Peak = strongestPeakInRange(sorted, 200, 1200)
  const f1 = f1Peak ? f1Peak.freq : findPeakInRange(envelope, sampleRate, 200, 1200)

  // F2: strongest peak above F1 in the F2 range
  const f2Min = f1 + 200
  const f2Peak = strongestPeakInRange(sorted, f2Min, 2800)
  const f2 = f2Peak ? f2Peak.freq : findPeakInRange(envelope, sampleRate, f2Min, 2800)

  // F3: lowest-frequency peak above F2
  const f3Min = f2 + 200
  const f3Peak = sorted.find(p => p.freq >= f3Min && p.freq <= 3800) ?? null
  const f3 = f3Peak ? f3Peak.freq : findPeakInRange(envelope, sampleRate, f3Min, 3800)

  return { f1, f2, f3 }
}

// --- Main detection ---

export const detectVowel = (
  buffer: Float32Array,
  sampleRate: number,
): Vowel | null => {
  if (computeRMS(buffer) < ENERGY_THRESHOLD) {
    return null
  }

  const preEmphasized = applyPreEmphasis(buffer)
  const windowed = applyHammingWindow(preEmphasized)

  // Decimate to ~8.8kHz for LPC (focuses all poles on the 0-4.4kHz formant region)
  const decimationFactor = Math.max(1, Math.floor(sampleRate / 7000))
  const decimated = decimateSignal(windowed, decimationFactor)
  const decimatedRate = sampleRate / decimationFactor

  const R = computeAutocorrelation(decimated, LPC_ORDER)
  const { coeffs, gain } = levinsonDurbin(R, LPC_ORDER)

  const magnitudes = computeFFTMagnitude(windowed)

  // Spectral energy balance: ratio of energy below 1500 Hz vs total (200-4000 Hz)
  const fftN = (magnitudes.length - 1) * 2
  const binToHz = sampleRate / fftN
  const minBin = Math.ceil(200 / binToHz)
  const splitBin = Math.round(1500 / binToHz)
  const maxBin = Math.floor(4000 / binToHz)

  let lowEnergy = 0
  let totalEnergy = 0
  for (let i = minBin; i <= maxBin && i < magnitudes.length; i++) {
    const e = magnitudes[i] * magnitudes[i]
    totalEnergy += e
    if (i <= splitBin) lowEnergy += e
  }
  const lowRatio = totalEnergy > 0 ? lowEnergy / totalEnergy : 0.5

  const fftSize = fftN
  const lpcEnvelope = evaluateLpcEnvelope(coeffs, gain, magnitudes.length, decimatedRate, sampleRate, fftSize)

  // Guided template matching: for each vowel, find the best-matching
  // peaks near its expected formant positions
  let bestVowel: Vowel | null = null
  let bestDist = Infinity

  for (const target of VOWEL_TARGETS) {
    // Search for peaks in a window around each target formant
    const f1Range = 200
    const f2Range = 300
    const f3Range = 400

    const f1 = findBestLocalPeakInRange(lpcEnvelope, sampleRate,
      Math.max(100, target.f1 - f1Range), target.f1 + f1Range)
    const f2 = findBestLocalPeakInRange(lpcEnvelope, sampleRate,
      Math.max(target.f1 + 100, target.f2 - f2Range), target.f2 + f2Range)
    const f3 = findBestLocalPeakInRange(lpcEnvelope, sampleRate,
      Math.max(target.f2 + 100, target.f3 - f3Range), target.f3 + f3Range)

    // Check that formant magnitudes are above threshold
    const f1Mag = peakMagnitudeAt(lpcEnvelope, sampleRate, f1)
    const f2Mag = peakMagnitudeAt(lpcEnvelope, sampleRate, f2)
    if (f1Mag < PEAK_MAGNITUDE_THRESHOLD || f2Mag < PEAK_MAGNITUDE_THRESHOLD) {
      continue
    }

    // Compute Bark-scale distance
    const b1 = hzToBark(f1)
    const b2 = hzToBark(f2)
    const b3 = hzToBark(f3)
    const d1 = b1 - hzToBark(target.f1)
    const d2 = b2 - hzToBark(target.f2)
    const d3 = b3 - hzToBark(target.f3)
    const dist = d1 * d1 + d2 * d2 + 0.8 * d3 * d3

    // Spectral balance penalty
    const expectedBalance = VOWEL_SPECTRAL_BALANCE[target.vowel] ?? 0.5
    const balanceDiff = lowRatio - expectedBalance
    const balancePenalty = balanceDiff * balanceDiff * 2.0  // weight of 2.0
    const totalDist = dist + balancePenalty

    if (totalDist < bestDist) {
      bestDist = totalDist
      bestVowel = target.vowel
    }
  }

  // Reject matches with high Bark distance (likely wrong)
  if (bestDist > 5.0) return null

  return bestVowel
}

export type FormantAnalysis = {
  readonly vowel: Vowel | null
  readonly formants: FormantData | null
}

export const analyzeFormants = (
  buffer: Float32Array,
  sampleRate: number,
): FormantAnalysis => {
  if (computeRMS(buffer) < ENERGY_THRESHOLD) {
    return { vowel: null, formants: null }
  }

  const preEmphasized = applyPreEmphasis(buffer)
  const windowed = applyHammingWindow(preEmphasized)
  const magnitudes = computeFFTMagnitude(windowed)

  const decimationFactor = Math.max(1, Math.floor(sampleRate / 11000))
  const decimated = decimateSignal(windowed, decimationFactor)
  const decimatedRate = sampleRate / decimationFactor

  const R = computeAutocorrelation(decimated, LPC_ORDER)
  const { coeffs, gain } = levinsonDurbin(R, LPC_ORDER)

  const fftSize = (magnitudes.length - 1) * 2
  const lpcEnvelope = evaluateLpcEnvelope(coeffs, gain, magnitudes.length, decimatedRate, sampleRate, fftSize)

  const { f1, f2, f3 } = extractFormants(lpcEnvelope, sampleRate)

  const f1Mag = peakMagnitudeAt(lpcEnvelope, sampleRate, f1)
  const f2Mag = peakMagnitudeAt(lpcEnvelope, sampleRate, f2)
  const f3Mag = peakMagnitudeAt(lpcEnvelope, sampleRate, f3)

  const formants: FormantData = { magnitudes, lpcEnvelope, sampleRate, fftSize, f1, f2, f3 }

  if (f1Mag < PEAK_MAGNITUDE_THRESHOLD || f2Mag < PEAK_MAGNITUDE_THRESHOLD || f3Mag < PEAK_MAGNITUDE_THRESHOLD) {
    return { vowel: null, formants }
  }

  return { vowel: classifyVowel(f1, f2, f3), formants }
}

// --- Internal utilities ---

const computeRMS = (buffer: Float32Array): number => {
  let sum = 0
  for (let i = 0; i < buffer.length; i++) {
    sum += buffer[i] * buffer[i]
  }
  return Math.sqrt(sum / buffer.length)
}

const nextPowerOfTwo = (n: number): number => {
  let p = 1
  while (p < n) {
    p *= 2
  }
  return p
}

const bitReversalPermute = (
  real: Float32Array,
  imag: Float32Array,
  n: number,
): void => {
  const bits = Math.log2(n)
  for (let i = 0; i < n; i++) {
    const j = reverseBits(i, bits)
    if (j > i) {
      // Swap real
      const tmpR = real[i]
      real[i] = real[j]
      real[j] = tmpR
      // Swap imag
      const tmpI = imag[i]
      imag[i] = imag[j]
      imag[j] = tmpI
    }
  }
}

const reverseBits = (x: number, bits: number): number => {
  let result = 0
  for (let i = 0; i < bits; i++) {
    result = (result << 1) | (x & 1)
    x >>= 1
  }
  return result
}

const peakMagnitudeAt = (
  magnitudes: Float32Array,
  sampleRate: number,
  freqHz: number,
): number => {
  const n = (magnitudes.length - 1) * 2
  const bin = Math.round((freqHz * n) / sampleRate)
  const clampedBin = Math.max(0, Math.min(magnitudes.length - 1, bin))
  return magnitudes[clampedBin]
}
